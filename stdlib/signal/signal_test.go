package signal_test

import (
	"os"
	"os/signal"
	"syscall"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

// ## Differences Between SIGTERM and SIGINT
//
// SIGTERM and SIGINT are both signals in Unix systems used to control process behavior, but they have different uses
// and meanings:
//
// ### SIGTERM (Signal Terminate):
//
// SIGTERM is a signal that requests the termination of a process. It is the default termination signal used by the
// system to request a process to shut down gracefully. A process that receives a SIGTERM can catch this signal and
// perform some cleanup operations, such as closing files, releasing resources, etc., before exiting. This provides an
// opportunity for a graceful shutdown. This is a catchable and ignorable signal, meaning a process can choose how to
// respond to it or even ignore it completely.

// ### SIGINT (Signal Interrupt):
//
// SIGINT is typically generated by the user through a keyboard interrupt, usually by pressing Ctrl+C. It sends an
// interrupt signal to the process, asking it to stop running. Like SIGTERM, a process can catch the SIGINT signal and
// perform some cleanup operations, but the user's intent in sending a SIGINT signal is usually to terminate the process
// immediately. SIGINT is also a catchable signal, allowing the process to handle the signal, or be terminated by the
// default behavior. In summary, SIGTERM is generally used for system requests for graceful process termination, while
// SIGINT is often used for user-initiated process interruption. The main differences lie in their triggers (system vs.
// user) and typical usage (graceful shutdown vs. user interruption).

func TestSendInterrupt(t *testing.T) {
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	go func() {
		process, err := os.FindProcess(os.Getpid())
		require.NoError(t, err)
		require.NoError(t, process.Signal(os.Interrupt))
	}()
	select {
	case <-c:
		t.Logf("Signal received, shutting down...")
	case <-time.After(3 * time.Second):
		t.Fatal("should receive signal")
	}
}

// The following test will fail
func TestSIGTERMDoesNotTriggerSIGINTHandler(t *testing.T) {
	c := make(chan os.Signal, 1)
	// Listen only for SIGINT (os.Interrupt)
	signal.Notify(c, os.Interrupt)

	// A separate channel to capture SIGTERM to prevent the test from exiting
	sigtermCaught := make(chan struct{})

	go func() {
		// Set up another signal handler for SIGTERM just for the test
		termChan := make(chan os.Signal, 1)
		signal.Notify(termChan, syscall.SIGTERM)
		<-termChan
		close(sigtermCaught)
	}()

	go func() {
		process, err := os.FindProcess(os.Getpid())
		require.NoError(t, err)
		require.NoError(t, process.Signal(syscall.SIGTERM)) // Sending SIGTERM
	}()

	select {
	case sig := <-c:
		t.Fatalf("Received unexpected signal: %v", sig) // Fails if SIGINT is caught, which shouldn't be
	case <-sigtermCaught:
		select {
		case sig := <-c:
			t.Fatalf("Received unexpected signal: %v", sig) // Fails if SIGINT is caught, which shouldn't be
		default:
			t.Logf("SIGTERM received but not processed by SIGINT handler, as expected.")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("should not reach here")
	}
}

func TestSendTerm(t *testing.T) {
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		process, err := os.FindProcess(os.Getpid())
		require.NoError(t, err)
		require.NoError(t, process.Signal(os.Kill))
	}()
	select {
	case <-c:
		t.Logf("Signal received, shutting down...")
	case <-time.After(3 * time.Second):
		t.Fatal("should receive signal")
	}
}
